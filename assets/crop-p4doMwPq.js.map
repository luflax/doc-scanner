{"version":3,"file":"crop-p4doMwPq.js","sources":["../../src/components/crop/CornerHandles.tsx","../../src/components/crop/CropView.tsx"],"sourcesContent":["import React, { useState, useRef, useEffect } from 'react';\nimport type { Point, Size } from '@/types';\n\ninterface CornerHandlesProps {\n  corners: Point[];\n  imageSize: Size;\n  containerSize: Size;\n  onChange: (corners: Point[]) => void;\n  onCommit?: () => void;\n  className?: string;\n}\n\nexport const CornerHandles: React.FC<CornerHandlesProps> = ({\n  corners,\n  imageSize,\n  containerSize,\n  onChange,\n  onCommit,\n  className = '',\n}) => {\n  const [draggingIndex, setDraggingIndex] = useState<number | null>(null);\n  const [localCorners, setLocalCorners] = useState<Point[]>(corners);\n  const svgRef = useRef<SVGSVGElement>(null);\n\n  // Update local corners when props change\n  useEffect(() => {\n    setLocalCorners(corners);\n  }, [corners]);\n\n  // Calculate scale factor to convert image coordinates to container coordinates\n  const getScale = (): { scaleX: number; scaleY: number; offsetX: number; offsetY: number } => {\n    const imageAspect = imageSize.width / imageSize.height;\n    const containerAspect = containerSize.width / containerSize.height;\n\n    let scaleX: number, scaleY: number;\n    let offsetX = 0;\n    let offsetY = 0;\n\n    if (imageAspect > containerAspect) {\n      // Image is wider - fit to width\n      scaleX = containerSize.width / imageSize.width;\n      scaleY = scaleX;\n      offsetY = (containerSize.height - imageSize.height * scaleY) / 2;\n    } else {\n      // Image is taller - fit to height\n      scaleY = containerSize.height / imageSize.height;\n      scaleX = scaleY;\n      offsetX = (containerSize.width - imageSize.width * scaleX) / 2;\n    }\n\n    return { scaleX, scaleY, offsetX, offsetY };\n  };\n\n  // Convert image coordinates to SVG coordinates\n  const imageToSVG = (point: Point): Point => {\n    const { scaleX, scaleY, offsetX, offsetY } = getScale();\n    return {\n      x: point.x * scaleX + offsetX,\n      y: point.y * scaleY + offsetY,\n    };\n  };\n\n  // Convert SVG coordinates to image coordinates\n  const svgToImage = (point: Point): Point => {\n    const { scaleX, scaleY, offsetX, offsetY } = getScale();\n    return {\n      x: (point.x - offsetX) / scaleX,\n      y: (point.y - offsetY) / scaleY,\n    };\n  };\n\n  // Get SVG coordinates from mouse/touch event\n  const getSVGPoint = (e: React.MouseEvent | React.TouchEvent): Point => {\n    if (!svgRef.current) return { x: 0, y: 0 };\n\n    const svg = svgRef.current;\n    const rect = svg.getBoundingClientRect();\n\n    let clientX: number, clientY: number;\n\n    if ('touches' in e) {\n      const touch = e.touches[0];\n      clientX = touch.clientX;\n      clientY = touch.clientY;\n    } else {\n      clientX = e.clientX;\n      clientY = e.clientY;\n    }\n\n    return {\n      x: clientX - rect.left,\n      y: clientY - rect.top,\n    };\n  };\n\n  // Handle mouse/touch down\n  const handlePointerDown = (index: number) => (e: React.MouseEvent | React.TouchEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n    setDraggingIndex(index);\n  };\n\n  // Handle mouse/touch move\n  const handlePointerMove = (e: React.MouseEvent | React.TouchEvent) => {\n    if (draggingIndex === null) return;\n\n    e.preventDefault();\n    const svgPoint = getSVGPoint(e);\n    const imagePoint = svgToImage(svgPoint);\n\n    // Clamp to image bounds\n    const clampedPoint = {\n      x: Math.max(0, Math.min(imageSize.width, imagePoint.x)),\n      y: Math.max(0, Math.min(imageSize.height, imagePoint.y)),\n    };\n\n    // Update local corners\n    const newCorners = [...localCorners];\n    newCorners[draggingIndex] = clampedPoint;\n    setLocalCorners(newCorners);\n    onChange(newCorners);\n  };\n\n  // Handle mouse/touch up\n  const handlePointerUp = () => {\n    if (draggingIndex !== null) {\n      setDraggingIndex(null);\n      onCommit?.();\n    }\n  };\n\n  // Convert corners to SVG coordinates\n  const svgCorners = localCorners.map(imageToSVG);\n\n  // Create polygon path\n  const polygonPath = svgCorners.length === 4\n    ? `M ${svgCorners[0].x} ${svgCorners[0].y} L ${svgCorners[1].x} ${svgCorners[1].y} L ${svgCorners[2].x} ${svgCorners[2].y} L ${svgCorners[3].x} ${svgCorners[3].y} Z`\n    : '';\n\n  return (\n    <svg\n      ref={svgRef}\n      className={`absolute inset-0 w-full h-full ${className}`}\n      style={{ touchAction: 'none' }}\n      onMouseMove={handlePointerMove}\n      onMouseUp={handlePointerUp}\n      onMouseLeave={handlePointerUp}\n      onTouchMove={handlePointerMove}\n      onTouchEnd={handlePointerUp}\n      onTouchCancel={handlePointerUp}\n    >\n      {/* Polygon overlay */}\n      {polygonPath && (\n        <>\n          {/* Semi-transparent fill */}\n          <path\n            d={polygonPath}\n            fill=\"rgba(59, 130, 246, 0.2)\"\n            stroke=\"none\"\n          />\n          {/* Border */}\n          <path\n            d={polygonPath}\n            fill=\"none\"\n            stroke=\"#3b82f6\"\n            strokeWidth=\"2\"\n          />\n        </>\n      )}\n\n      {/* Corner handles */}\n      {svgCorners.map((corner, index) => (\n        <g key={index}>\n          {/* Larger touch target */}\n          <circle\n            cx={corner.x}\n            cy={corner.y}\n            r=\"20\"\n            fill=\"transparent\"\n            style={{ cursor: 'grab' }}\n            onMouseDown={handlePointerDown(index)}\n            onTouchStart={handlePointerDown(index)}\n          />\n          {/* Visible handle */}\n          <circle\n            cx={corner.x}\n            cy={corner.y}\n            r=\"8\"\n            fill=\"white\"\n            stroke=\"#3b82f6\"\n            strokeWidth=\"3\"\n            style={{ cursor: 'grab', pointerEvents: 'none' }}\n          />\n          {/* Center dot */}\n          <circle\n            cx={corner.x}\n            cy={corner.y}\n            r=\"3\"\n            fill=\"#3b82f6\"\n            style={{ pointerEvents: 'none' }}\n          />\n        </g>\n      ))}\n\n      {/* Edge lines connecting corners */}\n      {svgCorners.length === 4 && svgCorners.map((corner, index) => {\n        const nextCorner = svgCorners[(index + 1) % 4];\n        return (\n          <line\n            key={`line-${index}`}\n            x1={corner.x}\n            y1={corner.y}\n            x2={nextCorner.x}\n            y2={nextCorner.y}\n            stroke=\"#3b82f6\"\n            strokeWidth=\"2\"\n            strokeDasharray=\"5,5\"\n            style={{ pointerEvents: 'none' }}\n          />\n        );\n      })}\n    </svg>\n  );\n};\n","import React, { useRef, useEffect, useState } from 'react';\nimport { useStore } from '@/store';\nimport { Button } from '@/components/common/Button';\nimport { Spinner } from '@/components/common/Spinner';\nimport { CornerHandles } from './CornerHandles';\nimport { edgeDetectionService } from '@/services/EdgeDetectionService';\nimport { perspectiveCorrectionService } from '@/services/PerspectiveCorrectionService';\nimport type { Point } from '@/types';\n\nexport const CropView: React.FC = () => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  const [isDetecting, setIsDetecting] = useState(false);\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [containerSize, setContainerSize] = useState({ width: 0, height: 0 });\n\n  const {\n    currentImage,\n    detectedEdges,\n    adjustedCorners,\n    setCurrentView,\n    resetScanSession,\n    setDetectedEdges,\n    setAdjustedCorners,\n    setProcessedImage,\n    addToast,\n  } = useStore((state) => ({\n    currentImage: state.scanSession.currentImage,\n    detectedEdges: state.scanSession.detectedEdges,\n    adjustedCorners: state.scanSession.adjustedCorners,\n    setCurrentView: state.setCurrentView,\n    resetScanSession: state.resetScanSession,\n    setDetectedEdges: state.setDetectedEdges,\n    setAdjustedCorners: state.setAdjustedCorners,\n    setProcessedImage: state.setProcessedImage,\n    addToast: state.addToast,\n  }));\n\n  // Draw image on canvas\n  useEffect(() => {\n    if (currentImage && canvasRef.current) {\n      const canvas = canvasRef.current;\n      const ctx = canvas.getContext('2d');\n      if (!ctx) return;\n\n      canvas.width = currentImage.width;\n      canvas.height = currentImage.height;\n      ctx.putImageData(currentImage, 0, 0);\n    }\n  }, [currentImage]);\n\n  // Detect edges on mount\n  useEffect(() => {\n    if (currentImage && !detectedEdges && !isDetecting) {\n      detectEdges();\n    }\n  }, [currentImage]);\n\n  // Update container size for corner handles\n  useEffect(() => {\n    const updateSize = () => {\n      if (containerRef.current) {\n        const rect = containerRef.current.getBoundingClientRect();\n        setContainerSize({ width: rect.width, height: rect.height });\n      }\n    };\n\n    updateSize();\n    window.addEventListener('resize', updateSize);\n    return () => window.removeEventListener('resize', updateSize);\n  }, []);\n\n  const detectEdges = async () => {\n    console.log('[CropView] detectEdges() called');\n    if (!currentImage) return;\n\n    console.log('[CropView] Setting isDetecting to true');\n    setIsDetecting(true);\n    try {\n      console.log('[CropView] Calling edgeDetectionService.detectDocument()');\n      const detected = await edgeDetectionService.detectDocument(currentImage);\n      console.log('[CropView] detectDocument() returned:', detected);\n\n      if (detected) {\n        setDetectedEdges(detected);\n        setAdjustedCorners(detected.contour);\n        addToast({\n          type: 'success',\n          message: 'Document detected!',\n        });\n      } else {\n        // Use default corners (full image)\n        const defaultCorners: Point[] = [\n          { x: 0, y: 0 },\n          { x: currentImage.width, y: 0 },\n          { x: currentImage.width, y: currentImage.height },\n          { x: 0, y: currentImage.height },\n        ];\n        setAdjustedCorners(defaultCorners);\n        addToast({\n          type: 'warning',\n          message: 'Could not detect document. Using full image.',\n        });\n      }\n    } catch (error) {\n      console.error('[CropView] Edge detection failed:', error);\n      addToast({\n        type: 'error',\n        message: 'Edge detection failed',\n      });\n    } finally {\n      console.log('[CropView] Setting isDetecting to false');\n      setIsDetecting(false);\n    }\n  };\n\n  const handleCornersChange = (newCorners: Point[]) => {\n    setAdjustedCorners(newCorners);\n  };\n\n  const handleRetake = () => {\n    resetScanSession();\n    setCurrentView('camera');\n  };\n\n  const handleContinue = async () => {\n    if (!currentImage || !adjustedCorners) {\n      return;\n    }\n\n    setIsProcessing(true);\n    try {\n      const result = await perspectiveCorrectionService.correctPerspective(\n        currentImage,\n        adjustedCorners\n      );\n\n      if (result) {\n        setProcessedImage(result.correctedImage);\n        setCurrentView('enhance');\n        addToast({\n          type: 'success',\n          message: 'Image cropped successfully!',\n        });\n      } else {\n        throw new Error('Perspective correction failed');\n      }\n    } catch (error) {\n      console.error('Perspective correction failed:', error);\n      addToast({\n        type: 'error',\n        message: 'Failed to crop image',\n      });\n    } finally {\n      setIsProcessing(false);\n    }\n  };\n\n  if (!currentImage) {\n    return (\n      <div className=\"flex flex-col items-center justify-center h-full bg-gray-50 p-6\">\n        <p className=\"text-gray-600\">No image captured</p>\n        <Button onClick={() => setCurrentView('camera')} className=\"mt-4\">\n          Back to Camera\n        </Button>\n      </div>\n    );\n  }\n\n  if (isDetecting) {\n    return (\n      <div className=\"flex flex-col items-center justify-center h-full bg-gray-900\">\n        <Spinner size=\"lg\" className=\"mb-4\" />\n        <p className=\"text-white text-sm\">Detecting document edges...</p>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"flex flex-col h-full bg-gray-900\">\n      {/* Canvas container */}\n      <div ref={containerRef} className=\"flex-1 overflow-hidden flex items-center justify-center p-4 relative\">\n        <canvas\n          ref={canvasRef}\n          className=\"max-w-full max-h-full object-contain\"\n        />\n\n        {/* Corner handles overlay */}\n        {adjustedCorners && currentImage && containerSize.width > 0 && (\n          <CornerHandles\n            corners={adjustedCorners}\n            imageSize={{ width: currentImage.width, height: currentImage.height }}\n            containerSize={containerSize}\n            onChange={handleCornersChange}\n          />\n        )}\n      </div>\n\n      {/* Action buttons */}\n      <div className=\"p-4 bg-white border-t border-gray-200\">\n        <div className=\"flex gap-3\">\n          <Button onClick={handleRetake} variant=\"secondary\" fullWidth disabled={isProcessing}>\n            Retake\n          </Button>\n          <Button onClick={detectEdges} variant=\"secondary\" fullWidth disabled={isProcessing}>\n            Auto-Detect\n          </Button>\n          <Button onClick={handleContinue} variant=\"primary\" fullWidth disabled={isProcessing}>\n            {isProcessing ? 'Processing...' : 'Continue'}\n          </Button>\n        </div>\n      </div>\n    </div>\n  );\n};\n"],"names":["CornerHandles","corners","imageSize","containerSize","onChange","onCommit","className","draggingIndex","setDraggingIndex","useState","localCorners","setLocalCorners","svgRef","useRef","useEffect","getScale","scaleX","scaleY","offsetX","offsetY","width","height","handlePointerDown","index","e","preventDefault","stopPropagation","handlePointerMove","svgPoint","current","x","y","rect","getBoundingClientRect","clientX","clientY","touch","touches","left","top","getSVGPoint","imagePoint","point","svgToImage","clampedPoint","Math","max","min","newCorners","handlePointerUp","svgCorners","map","polygonPath","length","jsxs","ref","style","touchAction","onMouseMove","onMouseUp","onMouseLeave","onTouchMove","onTouchEnd","onTouchCancel","children","Fragment","jsx","d","fill","stroke","strokeWidth","corner","cx","cy","r","cursor","onMouseDown","onTouchStart","pointerEvents","nextCorner","x1","y1","x2","y2","strokeDasharray","CropView","canvasRef","containerRef","isDetecting","setIsDetecting","isProcessing","setIsProcessing","setContainerSize","currentImage","detectedEdges","adjustedCorners","setCurrentView","resetScanSession","setDetectedEdges","setAdjustedCorners","setProcessedImage","addToast","useStore","state","scanSession","canvas","ctx","getContext","putImageData","detectEdges","updateSize","window","addEventListener","removeEventListener","async","detected","edgeDetectionService","detectDocument","contour","type","message","defaultCorners","error","Spinner","size","Button","onClick","variant","fullWidth","disabled","result","perspectiveCorrectionService","correctPerspective","Error","correctedImage"],"mappings":"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"}