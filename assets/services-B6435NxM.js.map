{"version":3,"file":"services-B6435NxM.js","sources":["../../src/services/CameraService.ts","../../src/lib/opencv-loader.ts","../../src/services/EdgeDetectionService.ts","../../src/services/PerspectiveCorrectionService.ts","../../src/services/ImageEnhancementService.ts","../../src/services/StorageService.ts","../../src/services/ExportService.ts","../../src/services/BulkExportService.ts","../../src/services/OCRService.ts"],"sourcesContent":["import type { CameraConfig, CameraCapabilities } from '@/types';\n\nexport class CameraService {\n  private stream: MediaStream | null = null;\n  private videoTrack: MediaStreamTrack | null = null;\n  private currentFacingMode: 'environment' | 'user' = 'environment';\n\n  /**\n   * Initialize camera with optimal settings\n   */\n  async initialize(config?: Partial<CameraConfig>): Promise<MediaStream> {\n    const defaultConfig: CameraConfig = {\n      facingMode: 'environment',\n      resolution: {\n        ideal: { width: 3840, height: 2160 },\n        min: { width: 1920, height: 1080 },\n      },\n      focusMode: 'continuous',\n      torch: false,\n    };\n\n    const finalConfig = { ...defaultConfig, ...config };\n    this.currentFacingMode = finalConfig.facingMode;\n\n    try {\n      // Try with ideal constraints first\n      const constraints: MediaStreamConstraints = {\n        video: {\n          facingMode: { ideal: finalConfig.facingMode },\n          width: { ideal: finalConfig.resolution.ideal.width },\n          height: { ideal: finalConfig.resolution.ideal.height },\n        },\n        audio: false,\n      };\n\n      this.stream = await navigator.mediaDevices.getUserMedia(constraints);\n      this.videoTrack = this.stream.getVideoTracks()[0];\n\n      return this.stream;\n    } catch (error) {\n      // Fallback to basic constraints\n      console.warn('Failed with ideal constraints, falling back to basic', error);\n\n      const fallbackConstraints: MediaStreamConstraints = {\n        video: {\n          facingMode: finalConfig.facingMode,\n          width: { ideal: 1920 },\n          height: { ideal: 1080 },\n        },\n        audio: false,\n      };\n\n      this.stream = await navigator.mediaDevices.getUserMedia(fallbackConstraints);\n      this.videoTrack = this.stream.getVideoTracks()[0];\n\n      return this.stream;\n    }\n  }\n\n  /**\n   * Get camera capabilities\n   */\n  getCapabilities(): CameraCapabilities | null {\n    if (!this.videoTrack) {\n      return null;\n    }\n\n    try {\n      const capabilities = this.videoTrack.getCapabilities();\n\n      return {\n        hasFlash: 'torch' in capabilities,\n        hasFocus: 'focusMode' in capabilities,\n        hasZoom: 'zoom' in capabilities,\n        maxZoom: (capabilities as any).zoom?.max || 1,\n        supportedResolutions: this.getSupportedResolutions(capabilities),\n      };\n    } catch (error) {\n      console.error('Failed to get camera capabilities', error);\n      return {\n        hasFlash: false,\n        hasFocus: false,\n        hasZoom: false,\n        maxZoom: 1,\n        supportedResolutions: [],\n      };\n    }\n  }\n\n  /**\n   * Get supported resolutions from capabilities\n   */\n  private getSupportedResolutions(capabilities: MediaTrackCapabilities): Array<{ width: number; height: number }> {\n    const resolutions: Array<{ width: number; height: number }> = [];\n\n    // Common mobile camera resolutions\n    const commonResolutions = [\n      { width: 3840, height: 2160 }, // 4K\n      { width: 1920, height: 1080 }, // 1080p\n      { width: 1280, height: 720 },  // 720p\n      { width: 640, height: 480 },   // VGA\n    ];\n\n    const maxWidth = capabilities.width?.max || 1920;\n    const maxHeight = capabilities.height?.max || 1080;\n\n    // Filter resolutions that are supported by the camera\n    for (const res of commonResolutions) {\n      if (res.width <= maxWidth && res.height <= maxHeight) {\n        resolutions.push(res);\n      }\n    }\n\n    return resolutions;\n  }\n\n  /**\n   * Switch between front and back camera\n   */\n  async switchCamera(): Promise<MediaStream> {\n    const newFacingMode = this.currentFacingMode === 'environment' ? 'user' : 'environment';\n\n    // Dispose current stream\n    this.dispose();\n\n    // Initialize with new facing mode\n    return this.initialize({ facingMode: newFacingMode });\n  }\n\n  /**\n   * Capture high-resolution photo from video stream\n   */\n  async capturePhoto(videoElement: HTMLVideoElement): Promise<ImageData> {\n    if (!this.stream) {\n      throw new Error('Camera not initialized');\n    }\n\n    const canvas = document.createElement('canvas');\n    canvas.width = videoElement.videoWidth;\n    canvas.height = videoElement.videoHeight;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n      throw new Error('Failed to get canvas context');\n    }\n\n    ctx.drawImage(videoElement, 0, 0);\n\n    return ctx.getImageData(0, 0, canvas.width, canvas.height);\n  }\n\n  /**\n   * Get real-time frame for preview processing\n   */\n  getVideoFrame(videoElement: HTMLVideoElement): ImageData | null {\n    if (!this.stream) {\n      return null;\n    }\n\n    try {\n      const canvas = document.createElement('canvas');\n      // Use smaller resolution for real-time processing\n      const width = Math.min(640, videoElement.videoWidth);\n      const height = Math.min(480, videoElement.videoHeight);\n\n      canvas.width = width;\n      canvas.height = height;\n\n      const ctx = canvas.getContext('2d');\n      if (!ctx) {\n        return null;\n      }\n\n      ctx.drawImage(videoElement, 0, 0, width, height);\n\n      return ctx.getImageData(0, 0, width, height);\n    } catch (error) {\n      console.error('Failed to get video frame', error);\n      return null;\n    }\n  }\n\n  /**\n   * Set zoom level\n   */\n  async setZoom(level: number): Promise<void> {\n    if (!this.videoTrack) {\n      throw new Error('Camera not initialized');\n    }\n\n    const capabilities = this.videoTrack.getCapabilities();\n    if (!('zoom' in capabilities)) {\n      throw new Error('Zoom not supported');\n    }\n\n    const constraints = {\n      advanced: [{ zoom: level } as any],\n    };\n\n    try {\n      await this.videoTrack.applyConstraints(constraints);\n    } catch (error) {\n      console.error('Failed to set zoom', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Toggle flash/torch\n   */\n  async toggleFlash(enabled: boolean): Promise<void> {\n    if (!this.videoTrack) {\n      throw new Error('Camera not initialized');\n    }\n\n    const capabilities = this.videoTrack.getCapabilities();\n    if (!('torch' in capabilities)) {\n      throw new Error('Flash not supported');\n    }\n\n    const constraints = {\n      advanced: [{ torch: enabled } as any],\n    };\n\n    try {\n      await this.videoTrack.applyConstraints(constraints);\n    } catch (error) {\n      console.error('Failed to toggle flash', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Set focus point (if supported)\n   */\n  async setFocusPoint(x: number, y: number): Promise<void> {\n    if (!this.videoTrack) {\n      throw new Error('Camera not initialized');\n    }\n\n    const capabilities = this.videoTrack.getCapabilities();\n    if (!('focusMode' in capabilities)) {\n      console.warn('Focus control not supported');\n      return;\n    }\n\n    // Note: Point-based focus is not widely supported yet\n    // This is a placeholder for future support\n    console.log('Focus point requested:', x, y);\n  }\n\n  /**\n   * Get current stream\n   */\n  getStream(): MediaStream | null {\n    return this.stream;\n  }\n\n  /**\n   * Get current facing mode\n   */\n  getCurrentFacingMode(): 'environment' | 'user' {\n    return this.currentFacingMode;\n  }\n\n  /**\n   * Check if camera is initialized\n   */\n  isInitialized(): boolean {\n    return this.stream !== null && this.videoTrack !== null;\n  }\n\n  /**\n   * Cleanup and stop camera stream\n   */\n  dispose(): void {\n    if (this.stream) {\n      this.stream.getTracks().forEach((track) => track.stop());\n      this.stream = null;\n    }\n    this.videoTrack = null;\n  }\n}\n\n// Export singleton instance\nexport const cameraService = new CameraService();\n","/**\n * OpenCV.js Loader\n * Dynamically loads OpenCV.js WASM library on-demand\n */\n\ndeclare global {\n  interface Window {\n    cv: any;\n    Module?: any;\n    __opencvLoadPromise?: Promise<any> | null;\n    __resolvePromise?: any;\n    __rejectPromise?: any;\n  }\n}\n\nlet isLoaded = false;\n\n/**\n * Load OpenCV.js from CDN\n */\nexport function loadOpenCV(): Promise<any> {\n  // Use a single global promise so hot-reload / multiple bundles share it\n  if (window.__opencvLoadPromise) return window.__opencvLoadPromise;\n  if (isLoaded && window.cv) return Promise.resolve(window.cv);\n\n  window.__opencvLoadPromise = new Promise((resolve, reject) => {\n    window.__resolvePromise = resolve;\n    window.__rejectPromise = reject;\n    // Ensure Module exists and we set the init callback BEFORE loading script\n    window.Module = window.Module || {};\n    const previousInit = window.Module.onRuntimeInitialized;\n\n    window.Module.onRuntimeInitialized = () => {\n      try {\n        isLoaded = true;\n        console.log('[loadOpenCV] Module.onRuntimeInitialized fired');\n        window.__resolvePromise(window.cv);\n      } catch (err) {\n        console.error('[loadOpenCV] error resolving promise', err);\n        window.__rejectPromise(err);\n      }\n    };\n\n    // Create script element\n    const script = document.createElement('script');\n    script.async = true;\n    script.src = 'https://docs.opencv.org/4.8.0/opencv.js';\n\n    script.onload = () => {\n      console.log('[loadOpenCV] script.onload executed; window.cv=', !!window.cv);\n      // If cv already initialized synchronously and Module callback won't be called,\n      // check for cv.Mat and resolve manually.\n      if (window.cv && window.cv.Mat) {\n        try {\n          if (!isLoaded) {\n            isLoaded = true;\n            console.log('[loadOpenCV] cv.Mat present on load â€” resolving immediately');\n            window.__resolvePromise(window.cv);\n          } else {\n            console.log('[loadOpenCV] already marked loaded');\n          }\n        } catch (err) {\n          console.error('[loadOpenCV] error resolving onload', err);\n          window.__rejectPromise(err);\n        }\n      }\n      // otherwise, wait for Module.onRuntimeInitialized to run\n    };\n\n    script.onerror = (ev) => {\n      console.error('[loadOpenCV] script.onerror', ev);\n      // clear the global promise so retries can happen\n      window.__opencvLoadPromise = null;\n      // restore previous init if any\n      if (previousInit) window.Module.onRuntimeInitialized = previousInit;\n      window.__rejectPromise(new Error('Failed to load OpenCV.js script'));\n    };\n\n    document.body.appendChild(script);\n  });\n\n  // Optional: attach catch so unhandled rejection doesn't get swallowed\n  window.__opencvLoadPromise.catch((e) => {\n    console.error('[loadOpenCV] promise rejected', e);\n  });\n\n  return window.__opencvLoadPromise;\n}\n\n/**\n * Check if OpenCV is loaded\n */\nexport function isOpenCVLoaded(): boolean {\n  return /**isLoaded &&**/ !!window.cv;\n}\n\n/**\n * Get OpenCV instance (assumes already loaded)\n */\nexport function getOpenCV(): any {\n  if (/**!isLoaded ||**/ !window.cv) {\n    throw new Error('OpenCV not loaded. Call loadOpenCV() first.');\n  }\n  return window.cv;\n}\n\n/**\n * Utility to convert ImageData to cv.Mat\n */\nexport function imageDataToMat(imageData: ImageData): any {\n  const cv = getOpenCV();\n  const mat = cv.matFromImageData(imageData);\n  return mat;\n}\n\n/**\n * Utility to convert cv.Mat to ImageData\n */\nexport function matToImageData(mat: any): ImageData {\n  const cv = getOpenCV();\n\n  // Create canvas to convert mat to ImageData\n  const canvas = document.createElement('canvas');\n  canvas.width = mat.cols;\n  canvas.height = mat.rows;\n  const ctx = canvas.getContext('2d');\n\n  if (!ctx) {\n    throw new Error('Failed to get canvas context');\n  }\n\n  // Show mat on canvas\n  cv.imshow(canvas, mat);\n\n  // Get ImageData from canvas\n  return ctx.getImageData(0, 0, canvas.width, canvas.height);\n}\n\n/**\n * Utility to convert cv.Mat to canvas\n */\nexport function matToCanvas(mat: any, canvas: HTMLCanvasElement): void {\n  const cv = getOpenCV();\n  cv.imshow(canvas, mat);\n}\n\n/**\n * Cleanup mat to free memory\n */\nexport function deleteMat(...mats: any[]): void {\n  for (const mat of mats) {\n    if (mat && mat.delete) {\n      mat.delete();\n    }\n  }\n}\n","import { imageDataToMat, deleteMat, isOpenCVLoaded } from '@/lib/opencv-loader';\nimport type { DetectedEdge, EdgeDetectionConfig, Point, Rectangle } from '@/types';\n\nexport class EdgeDetectionService {\n  private cv: any = null;\n  private isInitialized = false;\n\n  /**\n   * Initialize the edge detection service by loading OpenCV\n   */\n  async initialize(): Promise<void> {\n    console.log('[EdgeDetectionService] initialize() called, isInitialized:', this.isInitialized);\n    if (this.isInitialized) {\n      return;\n    }\n\n    try {\n      console.log('[EdgeDetectionService] Calling loadOpenCV()');\n      this.cv = (window.cv instanceof Promise) ? await window.cv : window.cv;\n      console.log('[EdgeDetectionService] loadOpenCV() completed, cv:', this.cv);\n      this.isInitialized = true;\n      console.log('[EdgeDetectionService] EdgeDetectionService initialized');\n    } catch (error) {\n      console.error('[EdgeDetectionService] Failed to initialize EdgeDetectionService:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Detect document edges in the image\n   */\n  async detectDocument(\n    imageData: ImageData,\n    config?: Partial<EdgeDetectionConfig>\n  ): Promise<DetectedEdge | null> {\n    console.log('[EdgeDetectionService] detectDocument() called, image size:', imageData.width, 'x', imageData.height);\n    if (!this.isInitialized) {\n      console.log('[EdgeDetectionService] Not initialized, calling initialize()');\n      await this.initialize();\n    }\n\n    const defaultConfig: EdgeDetectionConfig = {\n      cannyThreshold1: 50,\n      cannyThreshold2: 150,\n      blurKernelSize: 5,\n      dilationIterations: 2,\n      minAreaRatio: 0.1,\n      maxAreaRatio: 0.95,\n    };\n\n    const finalConfig = { ...defaultConfig, ...config };\n\n    let src: any = null;\n    let gray: any = null;\n    let blurred: any = null;\n    let edges: any = null;\n    let dilated: any = null;\n    let contours: any = null;\n    let hierarchy: any = null;\n\n    try {\n      console.log('[EdgeDetectionService] Starting edge detection pipeline');\n\n      // Convert ImageData to Mat\n      console.log('[EdgeDetectionService] Converting ImageData to Mat');\n      src = imageDataToMat(imageData);\n      console.log('[EdgeDetectionService] ImageData converted, Mat size:', src.rows, 'x', src.cols);\n\n      // Convert to grayscale\n      console.log('[EdgeDetectionService] Converting to grayscale');\n      gray = new this.cv.Mat();\n      this.cv.cvtColor(src, gray, this.cv.COLOR_RGBA2GRAY);\n      console.log('[EdgeDetectionService] Grayscale conversion complete');\n\n      // Apply Gaussian blur to reduce noise\n      console.log('[EdgeDetectionService] Applying Gaussian blur');\n      blurred = new this.cv.Mat();\n      const ksize = new this.cv.Size(finalConfig.blurKernelSize, finalConfig.blurKernelSize);\n      this.cv.GaussianBlur(gray, blurred, ksize, 0);\n      console.log('[EdgeDetectionService] Gaussian blur complete');\n\n      // Apply Canny edge detection\n      console.log('[EdgeDetectionService] Applying Canny edge detection');\n      edges = new this.cv.Mat();\n      this.cv.Canny(blurred, edges, finalConfig.cannyThreshold1, finalConfig.cannyThreshold2);\n      console.log('[EdgeDetectionService] Canny edge detection complete');\n\n      // Dilate edges to close gaps\n      console.log('[EdgeDetectionService] Dilating edges');\n      dilated = new this.cv.Mat();\n      const kernel = this.cv.Mat.ones(3, 3, this.cv.CV_8U);\n      this.cv.dilate(edges, dilated, kernel, new this.cv.Point(-1, -1), finalConfig.dilationIterations);\n      kernel.delete();\n      console.log('[EdgeDetectionService] Edge dilation complete');\n\n      // Find contours\n      console.log('[EdgeDetectionService] Finding contours');\n      contours = new this.cv.MatVector();\n      hierarchy = new this.cv.Mat();\n      this.cv.findContours(\n        dilated,\n        contours,\n        hierarchy,\n        this.cv.RETR_EXTERNAL,\n        this.cv.CHAIN_APPROX_SIMPLE\n      );\n      console.log('[EdgeDetectionService] Found', contours.size(), 'contours');\n\n      // Find the best quadrilateral\n      console.log('[EdgeDetectionService] Finding best quadrilateral');\n      const result = this.findBestQuadrilateral(\n        contours,\n        imageData.width,\n        imageData.height,\n        finalConfig\n      );\n      console.log('[EdgeDetectionService] Best quadrilateral result:', result);\n\n      return result;\n    } catch (error) {\n      console.error('[EdgeDetectionService] Edge detection failed:', error);\n      return null;\n    } finally {\n      console.log('[EdgeDetectionService] Cleaning up resources');\n      // Cleanup\n      deleteMat(src, gray, blurred, edges, dilated, hierarchy);\n      if (contours) contours.delete();\n      console.log('[EdgeDetectionService] Cleanup complete');\n    }\n  }\n\n  /**\n   * Find the best quadrilateral from contours\n   */\n  private findBestQuadrilateral(\n    contours: any,\n    imageWidth: number,\n    imageHeight: number,\n    config: EdgeDetectionConfig\n  ): DetectedEdge | null {\n    const imageArea = imageWidth * imageHeight;\n    const minArea = imageArea * config.minAreaRatio;\n    const maxArea = imageArea * config.maxAreaRatio;\n\n    let bestContour: DetectedEdge | null = null;\n    let bestScore = 0;\n\n    for (let i = 0; i < contours.size(); i++) {\n      const contour = contours.get(i);\n\n      // Get contour area\n      const area = this.cv.contourArea(contour);\n\n      // Skip if area is too small or too large\n      if (area < minArea || area > maxArea) {\n        continue;\n      }\n\n      // Approximate contour to polygon\n      const perimeter = this.cv.arcLength(contour, true);\n      const approx = new this.cv.Mat();\n      this.cv.approxPolyDP(contour, approx, 0.02 * perimeter, true);\n\n      // We're looking for quadrilaterals (4 points)\n      if (approx.rows === 4) {\n        const points = this.matToPoints(approx);\n        const boundingRect = this.getBoundingRect(points);\n        const aspectRatio = boundingRect.width / boundingRect.height;\n\n        // Score this quadrilateral\n        const score = this.scoreQuadrilateral(points, area, aspectRatio, imageArea);\n\n        if (score > bestScore) {\n          bestScore = score;\n          bestContour = {\n            contour: this.orderCorners(points),\n            confidence: Math.min(score / 100, 1.0),\n            area,\n            aspectRatio,\n            boundingRect,\n          };\n        }\n      }\n\n      approx.delete();\n    }\n\n    return bestContour;\n  }\n\n  /**\n   * Score a quadrilateral based on various factors\n   */\n  private scoreQuadrilateral(\n    points: Point[],\n    area: number,\n    aspectRatio: number,\n    imageArea: number\n  ): number {\n    let score = 0;\n\n    // Area score (larger is better, up to a point)\n    const areaRatio = area / imageArea;\n    score += areaRatio * 50;\n\n    // Aspect ratio score (prefer document-like ratios: A4 is ~1.41, letter is ~1.29)\n    const targetRatios = [1.0, 1.29, 1.41, 1.5];\n    const ratioScore = targetRatios.reduce((best, target) => {\n      const diff = Math.abs(aspectRatio - target);\n      const currentScore = Math.max(0, 25 - diff * 20);\n      return Math.max(best, currentScore);\n    }, 0);\n    score += ratioScore;\n\n    // Convexity score (check if it's roughly convex)\n    const convexityScore = this.isRoughlyConvex(points) ? 25 : 0;\n    score += convexityScore;\n\n    return score;\n  }\n\n  /**\n   * Check if quadrilateral is roughly convex\n   */\n  private isRoughlyConvex(points: Point[]): boolean {\n    // A simple check: cross products should all have the same sign\n    if (points.length !== 4) return false;\n\n    const crossProducts = [];\n    for (let i = 0; i < 4; i++) {\n      const p1 = points[i];\n      const p2 = points[(i + 1) % 4];\n      const p3 = points[(i + 2) % 4];\n\n      const cross =\n        (p2.x - p1.x) * (p3.y - p2.y) - (p2.y - p1.y) * (p3.x - p2.x);\n      crossProducts.push(cross);\n    }\n\n    // All should have the same sign\n    const allPositive = crossProducts.every((cp) => cp > 0);\n    const allNegative = crossProducts.every((cp) => cp < 0);\n\n    return allPositive || allNegative;\n  }\n\n  /**\n   * Convert cv.Mat to Point array\n   */\n  private matToPoints(mat: any): Point[] {\n    const points: Point[] = [];\n    for (let i = 0; i < mat.rows; i++) {\n      const x = mat.data32S[i * 2];\n      const y = mat.data32S[i * 2 + 1];\n      points.push({ x, y });\n    }\n    return points;\n  }\n\n  /**\n   * Get bounding rectangle from points\n   */\n  private getBoundingRect(points: Point[]): Rectangle {\n    const xs = points.map((p) => p.x);\n    const ys = points.map((p) => p.y);\n\n    const minX = Math.min(...xs);\n    const maxX = Math.max(...xs);\n    const minY = Math.min(...ys);\n    const maxY = Math.max(...ys);\n\n    return {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY,\n    };\n  }\n\n  /**\n   * Order corners: top-left, top-right, bottom-right, bottom-left\n   */\n  private orderCorners(points: Point[]): Point[] {\n    if (points.length !== 4) {\n      return points;\n    }\n\n    // Sort by y coordinate\n    const sorted = [...points].sort((a, b) => a.y - b.y);\n\n    // Top two points\n    const topPoints = sorted.slice(0, 2).sort((a, b) => a.x - b.x);\n    // Bottom two points\n    const bottomPoints = sorted.slice(2, 4).sort((a, b) => a.x - b.x);\n\n    return [\n      topPoints[0],     // top-left\n      topPoints[1],     // top-right\n      bottomPoints[1],  // bottom-right\n      bottomPoints[0],  // bottom-left\n    ];\n  }\n\n  /**\n   * Check if service is initialized\n   */\n  isReady(): boolean {\n    return this.isInitialized && isOpenCVLoaded();\n  }\n}\n\n// Export singleton instance\nexport const edgeDetectionService = new EdgeDetectionService();\n","import { getOpenCV, imageDataToMat, matToImageData, deleteMat, isOpenCVLoaded } from '@/lib/opencv-loader';\nimport type { Point, PerspectiveConfig, TransformResult } from '@/types';\n\nexport class PerspectiveCorrectionService {\n  /**\n   * Apply perspective correction to image based on corner points\n   */\n  async correctPerspective(\n    imageData: ImageData,\n    corners: Point[],\n    config?: Partial<PerspectiveConfig>\n  ): Promise<TransformResult | null> {\n    if (!isOpenCVLoaded()) {\n      throw new Error('OpenCV not loaded');\n    }\n\n    if (corners.length !== 4) {\n      throw new Error('Exactly 4 corners required');\n    }\n\n    const defaultConfig: PerspectiveConfig = {\n      outputWidth: 0,\n      outputHeight: 0,\n      preserveAspectRatio: true,\n      interpolation: 'linear',\n    };\n\n    const finalConfig = { ...defaultConfig, ...config };\n\n    let src: any = null;\n    let dst: any = null;\n    let M: any = null;\n\n    try {\n      const cv = getOpenCV();\n\n      // Convert ImageData to Mat\n      src = imageDataToMat(imageData);\n\n      // Calculate output dimensions\n      const outputDimensions =\n        finalConfig.outputWidth && finalConfig.outputHeight\n          ? { width: finalConfig.outputWidth, height: finalConfig.outputHeight }\n          : this.calculateOutputDimensions(corners);\n\n      // Order corners: top-left, top-right, bottom-right, bottom-left\n      const orderedCorners = this.ensureCornerOrder(corners);\n\n      // Source points (detected corners)\n      const srcPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [\n        orderedCorners[0].x, orderedCorners[0].y,\n        orderedCorners[1].x, orderedCorners[1].y,\n        orderedCorners[2].x, orderedCorners[2].y,\n        orderedCorners[3].x, orderedCorners[3].y,\n      ]);\n\n      // Destination points (rectangle corners)\n      const dstPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [\n        0, 0,\n        outputDimensions.width, 0,\n        outputDimensions.width, outputDimensions.height,\n        0, outputDimensions.height,\n      ]);\n\n      // Compute perspective transform matrix\n      M = cv.getPerspectiveTransform(srcPoints, dstPoints);\n\n      // Apply perspective warp\n      dst = new cv.Mat();\n      const dsize = new cv.Size(outputDimensions.width, outputDimensions.height);\n\n      const interpolationFlag = this.getInterpolationFlag(finalConfig.interpolation);\n\n      cv.warpPerspective(\n        src,\n        dst,\n        M,\n        dsize,\n        interpolationFlag,\n        cv.BORDER_CONSTANT,\n        new cv.Scalar(255, 255, 255, 255)\n      );\n\n      // Convert result back to ImageData\n      const correctedImage = matToImageData(dst);\n\n      // Extract transform matrix as 2D array\n      const transformMatrix = this.matrixToArray(M);\n\n      srcPoints.delete();\n      dstPoints.delete();\n\n      return {\n        correctedImage,\n        transformMatrix,\n        originalCorners: orderedCorners,\n        outputDimensions,\n      };\n    } catch (error) {\n      console.error('Perspective correction failed:', error);\n      return null;\n    } finally {\n      deleteMat(src, dst, M);\n    }\n  }\n\n  /**\n   * Calculate optimal output dimensions based on corner points\n   */\n  calculateOutputDimensions(corners: Point[]): { width: number; height: number } {\n    if (corners.length !== 4) {\n      throw new Error('Exactly 4 corners required');\n    }\n\n    const orderedCorners = this.ensureCornerOrder(corners);\n\n    // Calculate distances\n    const topWidth = this.distance(orderedCorners[0], orderedCorners[1]);\n    const bottomWidth = this.distance(orderedCorners[3], orderedCorners[2]);\n    const leftHeight = this.distance(orderedCorners[0], orderedCorners[3]);\n    const rightHeight = this.distance(orderedCorners[1], orderedCorners[2]);\n\n    // Use maximum dimensions\n    const width = Math.max(topWidth, bottomWidth);\n    const height = Math.max(leftHeight, rightHeight);\n\n    return {\n      width: Math.round(width),\n      height: Math.round(height),\n    };\n  }\n\n  /**\n   * Calculate Euclidean distance between two points\n   */\n  private distance(p1: Point, p2: Point): number {\n    const dx = p2.x - p1.x;\n    const dy = p2.y - p1.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  /**\n   * Ensure corners are ordered: top-left, top-right, bottom-right, bottom-left\n   */\n  private ensureCornerOrder(points: Point[]): Point[] {\n    if (points.length !== 4) {\n      return points;\n    }\n\n    // Calculate centroid\n    const centroid = {\n      x: points.reduce((sum, p) => sum + p.x, 0) / 4,\n      y: points.reduce((sum, p) => sum + p.y, 0) / 4,\n    };\n\n    // Sort points by angle from centroid\n    const sorted = [...points].sort((a, b) => {\n      const angleA = Math.atan2(a.y - centroid.y, a.x - centroid.x);\n      const angleB = Math.atan2(b.y - centroid.y, b.x - centroid.x);\n      return angleA - angleB;\n    });\n\n    // Find top-left point (minimum x + y)\n    const sums = sorted.map((p) => p.x + p.y);\n    const topLeftIndex = sums.indexOf(Math.min(...sums));\n\n    // Reorder starting from top-left, going clockwise\n    const ordered = [\n      sorted[topLeftIndex],\n      sorted[(topLeftIndex + 1) % 4],\n      sorted[(topLeftIndex + 2) % 4],\n      sorted[(topLeftIndex + 3) % 4],\n    ];\n\n    return ordered;\n  }\n\n  /**\n   * Get OpenCV interpolation flag from string\n   */\n  private getInterpolationFlag(interpolation: string): number {\n    const cv = getOpenCV();\n\n    switch (interpolation) {\n      case 'nearest':\n        return cv.INTER_NEAREST;\n      case 'linear':\n        return cv.INTER_LINEAR;\n      case 'cubic':\n        return cv.INTER_CUBIC;\n      case 'lanczos':\n        return cv.INTER_LANCZOS4;\n      default:\n        return cv.INTER_LINEAR;\n    }\n  }\n\n  /**\n   * Convert cv.Mat to 2D array\n   */\n  private matrixToArray(mat: any): number[][] {\n    const result: number[][] = [];\n    for (let i = 0; i < mat.rows; i++) {\n      const row: number[] = [];\n      for (let j = 0; j < mat.cols; j++) {\n        row.push(mat.data64F[i * mat.cols + j]);\n      }\n      result.push(row);\n    }\n    return result;\n  }\n}\n\n// Export singleton instance\nexport const perspectiveCorrectionService = new PerspectiveCorrectionService();\n","import { imageDataToMat, matToImageData, deleteMat, isOpenCVLoaded } from '@/lib/opencv-loader';\nimport type { EnhancementOptions, FilterPreset } from '@/types';\n\nexport class ImageEnhancementService {\n  private cv: any = null;\n  private isInitialized = false;\n\n  /**\n   * Initialize the enhancement service by loading OpenCV\n   */\n  async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      return;\n    }\n\n    try {\n      this.cv = (window.cv instanceof Promise) ? await window.cv : window.cv;\n      this.isInitialized = true;\n      console.log('ImageEnhancementService initialized');\n    } catch (error) {\n      console.error('Failed to initialize ImageEnhancementService:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Apply manual enhancement adjustments\n   */\n  async enhance(imageData: ImageData, options: EnhancementOptions): Promise<ImageData | null> {\n    if (!this.isInitialized) {\n      await this.initialize();\n    }\n\n    let src: any = null;\n    let result: any = null;\n\n    try {\n      src = imageDataToMat(imageData);\n      result = src.clone();\n\n      // Apply brightness and contrast\n      if (options.brightness !== 0 || options.contrast !== 0) {\n        const alpha = 1 + (options.contrast / 100); // Contrast multiplier\n        const beta = (options.brightness / 100) * 255; // Brightness offset\n        result.convertTo(result, -1, alpha, beta);\n      }\n\n      // Apply gamma correction\n      if (options.gamma !== 1.0) {\n        this.applyGamma(result, options.gamma);\n      }\n\n      // Convert to HSV for saturation adjustment\n      if (options.saturation !== 0) {\n        this.applySaturation(result, options.saturation);\n      }\n\n      return matToImageData(result);\n    } catch (error) {\n      console.error('Enhancement failed:', error);\n      return null;\n    } finally {\n      deleteMat(src, result);\n    }\n  }\n\n  /**\n   * Apply a filter preset\n   */\n  async applyFilter(imageData: ImageData, preset: FilterPreset): Promise<ImageData | null> {\n    if (!this.isInitialized) {\n      await this.initialize();\n    }\n\n    switch (preset) {\n      case 'original':\n        return imageData;\n      case 'grayscale':\n        return this.applyGrayscale(imageData);\n      case 'document':\n        return this.applyDocumentFilter(imageData);\n      case 'magic':\n        return this.applyMagicFilter(imageData);\n      case 'whiteboard':\n        return this.applyWhiteboardFilter(imageData);\n      case 'book':\n        return this.applyBookFilter(imageData);\n      case 'receipt':\n        return this.applyReceiptFilter(imageData);\n      case 'photo':\n        return this.applyPhotoFilter(imageData);\n      case 'blueprint':\n        return this.applyBlueprintFilter(imageData);\n      default:\n        return imageData;\n    }\n  }\n\n  /**\n   * Grayscale filter\n   */\n  private applyGrayscale(imageData: ImageData): ImageData | null {\n    let src: any = null;\n    let gray: any = null;\n    let result: any = null;\n\n    try {\n      src = imageDataToMat(imageData);\n      gray = new this.cv.Mat();\n\n      // Convert to grayscale\n      this.cv.cvtColor(src, gray, this.cv.COLOR_RGBA2GRAY);\n\n      // Convert back to RGBA for display\n      result = new this.cv.Mat();\n      this.cv.cvtColor(gray, result, this.cv.COLOR_GRAY2RGBA);\n\n      // Increase contrast slightly\n      result.convertTo(result, -1, 1.1, 5);\n\n      return matToImageData(result);\n    } catch (error) {\n      console.error('Grayscale filter failed:', error);\n      return null;\n    } finally {\n      deleteMat(src, gray, result);\n    }\n  }\n\n  /**\n   * Document filter - High contrast black and white with adaptive threshold\n   */\n  private applyDocumentFilter(imageData: ImageData): ImageData | null {\n    let src: any = null;\n    let gray: any = null;\n    let denoised: any = null;\n    let threshold: any = null;\n    let result: any = null;\n\n    try {\n      src = imageDataToMat(imageData);\n      gray = new this.cv.Mat();\n\n      // Convert to grayscale\n      this.cv.cvtColor(src, gray, this.cv.COLOR_RGBA2GRAY);\n\n      // Denoise\n      denoised = new this.cv.Mat();\n      this.cv.fastNlMeansDenoising(gray, denoised, 10, 7, 21);\n\n      // Apply adaptive threshold\n      threshold = new this.cv.Mat();\n      this.cv.adaptiveThreshold(\n        denoised,\n        threshold,\n        255,\n        this.cv.ADAPTIVE_THRESH_GAUSSIAN_C,\n        this.cv.THRESH_BINARY,\n        11,\n        2\n      );\n\n      // Convert back to RGBA\n      result = new this.cv.Mat();\n      this.cv.cvtColor(threshold, result, this.cv.COLOR_GRAY2RGBA);\n\n      return matToImageData(result);\n    } catch (error) {\n      console.error('Document filter failed:', error);\n      return null;\n    } finally {\n      deleteMat(src, gray, denoised, threshold, result);\n    }\n  }\n\n  /**\n   * Magic filter - Auto-enhanced color\n   */\n  private applyMagicFilter(imageData: ImageData): ImageData | null {\n    let src: any = null;\n    let lab: any = null;\n    let channels: any = null;\n    let l: any = null;\n    let result: any = null;\n\n    try {\n      src = imageDataToMat(imageData);\n\n      // Convert to LAB color space\n      lab = new this.cv.Mat();\n      this.cv.cvtColor(src, lab, this.cv.COLOR_RGBA2RGB);\n      this.cv.cvtColor(lab, lab, this.cv.COLOR_RGB2Lab);\n\n      // Split channels\n      channels = new this.cv.MatVector();\n      this.cv.split(lab, channels);\n\n      // Apply CLAHE to L channel\n      l = channels.get(0);\n      const clahe = new this.cv.CLAHE(2.0, new this.cv.Size(8, 8));\n      clahe.apply(l, l);\n\n      // Merge back\n      this.cv.merge(channels, lab);\n\n      // Convert back to RGB then RGBA\n      result = new this.cv.Mat();\n      this.cv.cvtColor(lab, result, this.cv.COLOR_Lab2RGB);\n      this.cv.cvtColor(result, result, this.cv.COLOR_RGB2RGBA);\n\n      // Slight saturation boost\n      result.convertTo(result, -1, 1.1, 0);\n\n      channels.delete();\n      clahe.delete();\n\n      return matToImageData(result);\n    } catch (error) {\n      console.error('Magic filter failed:', error);\n      return null;\n    } finally {\n      deleteMat(src, lab, l, result);\n    }\n  }\n\n  /**\n   * Whiteboard filter - Optimized for whiteboards\n   */\n  private applyWhiteboardFilter(imageData: ImageData): ImageData | null {\n    let src: any = null;\n    let gray: any = null;\n    let blurred: any = null;\n    let threshold: any = null;\n    let result: any = null;\n\n    try {\n      src = imageDataToMat(imageData);\n      gray = new this.cv.Mat();\n\n      // Convert to grayscale\n      this.cv.cvtColor(src, gray, this.cv.COLOR_RGBA2GRAY);\n\n      // Blur to reduce noise\n      blurred = new this.cv.Mat();\n      this.cv.GaussianBlur(gray, blurred, new this.cv.Size(5, 5), 0);\n\n      // Adaptive threshold with larger block size for whiteboards\n      threshold = new this.cv.Mat();\n      this.cv.adaptiveThreshold(\n        blurred,\n        threshold,\n        255,\n        this.cv.ADAPTIVE_THRESH_GAUSSIAN_C,\n        this.cv.THRESH_BINARY,\n        15,\n        10\n      );\n\n      // Convert back to RGBA\n      result = new this.cv.Mat();\n      this.cv.cvtColor(threshold, result, this.cv.COLOR_GRAY2RGBA);\n\n      // Brighten slightly\n      result.convertTo(result, -1, 1.0, 10);\n\n      return matToImageData(result);\n    } catch (error) {\n      console.error('Whiteboard filter failed:', error);\n      return null;\n    } finally {\n      deleteMat(src, gray, blurred, threshold, result);\n    }\n  }\n\n  /**\n   * Book filter - Optimized for book pages\n   */\n  private applyBookFilter(imageData: ImageData): ImageData | null {\n    let src: any = null;\n    let gray: any = null;\n    let denoised: any = null;\n    let sharpened: any = null;\n    let result: any = null;\n\n    try {\n      src = imageDataToMat(imageData);\n      gray = new this.cv.Mat();\n\n      // Convert to grayscale\n      this.cv.cvtColor(src, gray, this.cv.COLOR_RGBA2GRAY);\n\n      // Denoise\n      denoised = new this.cv.Mat();\n      this.cv.fastNlMeansDenoising(gray, denoised, 10, 7, 21);\n\n      // Sharpen\n      sharpened = new this.cv.Mat();\n      const kernel = this.cv.matFromArray(3, 3, this.cv.CV_32F, [\n        0, -1, 0,\n        -1, 5, -1,\n        0, -1, 0\n      ]);\n      this.cv.filter2D(denoised, sharpened, this.cv.CV_8U, kernel);\n      kernel.delete();\n\n      // Convert back to RGBA\n      result = new this.cv.Mat();\n      this.cv.cvtColor(sharpened, result, this.cv.COLOR_GRAY2RGBA);\n\n      // Increase contrast\n      result.convertTo(result, -1, 1.2, 0);\n\n      return matToImageData(result);\n    } catch (error) {\n      console.error('Book filter failed:', error);\n      return null;\n    } finally {\n      deleteMat(src, gray, denoised, sharpened, result);\n    }\n  }\n\n  /**\n   * Receipt filter - High contrast for receipts\n   */\n  private applyReceiptFilter(imageData: ImageData): ImageData | null {\n    // Similar to document filter but with more aggressive contrast\n    let src: any = null;\n    let gray: any = null;\n    let threshold: any = null;\n    let result: any = null;\n\n    try {\n      src = imageDataToMat(imageData);\n      gray = new this.cv.Mat();\n\n      // Convert to grayscale\n      this.cv.cvtColor(src, gray, this.cv.COLOR_RGBA2GRAY);\n\n      // Otsu's threshold for receipts\n      threshold = new this.cv.Mat();\n      this.cv.threshold(gray, threshold, 0, 255, this.cv.THRESH_BINARY + this.cv.THRESH_OTSU);\n\n      // Convert back to RGBA\n      result = new this.cv.Mat();\n      this.cv.cvtColor(threshold, result, this.cv.COLOR_GRAY2RGBA);\n\n      return matToImageData(result);\n    } catch (error) {\n      console.error('Receipt filter failed:', error);\n      return null;\n    } finally {\n      deleteMat(src, gray, threshold, result);\n    }\n  }\n\n  /**\n   * Photo filter - Color preservation\n   */\n  private applyPhotoFilter(imageData: ImageData): ImageData | null {\n    let src: any = null;\n    let result: any = null;\n\n    try {\n      src = imageDataToMat(imageData);\n      result = src.clone();\n\n      // Slight enhancement - brightness and contrast\n      result.convertTo(result, -1, 1.1, 5);\n\n      return matToImageData(result);\n    } catch (error) {\n      console.error('Photo filter failed:', error);\n      return null;\n    } finally {\n      deleteMat(src, result);\n    }\n  }\n\n  /**\n   * Blueprint filter - Inverted colors\n   */\n  private applyBlueprintFilter(imageData: ImageData): ImageData | null {\n    let src: any = null;\n    let gray: any = null;\n    let inverted: any = null;\n    let result: any = null;\n\n    try {\n      src = imageDataToMat(imageData);\n      gray = new this.cv.Mat();\n\n      // Convert to grayscale\n      this.cv.cvtColor(src, gray, this.cv.COLOR_RGBA2GRAY);\n\n      // Invert\n      inverted = new this.cv.Mat();\n      this.cv.bitwise_not(gray, inverted);\n\n      // Convert back to RGBA with blue tint\n      result = new this.cv.Mat();\n      this.cv.cvtColor(inverted, result, this.cv.COLOR_GRAY2RGBA);\n\n      return matToImageData(result);\n    } catch (error) {\n      console.error('Blueprint filter failed:', error);\n      return null;\n    } finally {\n      deleteMat(src, gray, inverted, result);\n    }\n  }\n\n  /**\n   * Apply gamma correction\n   */\n  private applyGamma(mat: any, gamma: number): void {\n    const lookupTable = new Uint8Array(256);\n    for (let i = 0; i < 256; i++) {\n      lookupTable[i] = Math.pow(i / 255.0, gamma) * 255.0;\n    }\n\n    const data = mat.data;\n    for (let i = 0; i < data.length; i += 4) {\n      data[i] = lookupTable[data[i]];         // R\n      data[i + 1] = lookupTable[data[i + 1]]; // G\n      data[i + 2] = lookupTable[data[i + 2]]; // B\n      // Alpha channel (i+3) unchanged\n    }\n  }\n\n  /**\n   * Apply saturation adjustment\n   */\n  private applySaturation(mat: any, saturation: number): void {\n    // Convert to HSV\n    const hsv = new this.cv.Mat();\n    this.cv.cvtColor(mat, hsv, this.cv.COLOR_RGBA2RGB);\n    this.cv.cvtColor(hsv, hsv, this.cv.COLOR_RGB2HSV);\n\n    // Split channels\n    const channels = new this.cv.MatVector();\n    this.cv.split(hsv, channels);\n\n    // Adjust saturation (S channel)\n    const s = channels.get(1);\n    const factor = 1 + (saturation / 100);\n    s.convertTo(s, -1, factor, 0);\n\n    // Merge back\n    this.cv.merge(channels, hsv);\n\n    // Convert back to RGBA\n    this.cv.cvtColor(hsv, mat, this.cv.COLOR_HSV2RGB);\n    this.cv.cvtColor(mat, mat, this.cv.COLOR_RGB2RGBA);\n\n    hsv.delete();\n    channels.delete();\n  }\n\n  /**\n   * Check if service is initialized\n   */\n  isReady(): boolean {\n    return this.isInitialized && isOpenCVLoaded();\n  }\n}\n\n// Export singleton instance\nexport const imageEnhancementService = new ImageEnhancementService();\n","import { openDB, type IDBPDatabase } from 'idb';\nimport type { Document, DocumentPage, ListOptions, SearchResult, StorageUsage } from '@/types';\n\nconst DB_NAME = 'doc-scanner-db';\nconst DB_VERSION = 1;\nconst DOCUMENTS_STORE = 'documents';\nconst PAGES_STORE = 'pages';\n\nexport class StorageService {\n  private db: IDBPDatabase | null = null;\n\n  /**\n   * Initialize the database\n   */\n  async initialize(): Promise<void> {\n    if (this.db) return;\n\n    this.db = await openDB(DB_NAME, DB_VERSION, {\n      upgrade(db) {\n        // Create documents store\n        if (!db.objectStoreNames.contains(DOCUMENTS_STORE)) {\n          const documentsStore = db.createObjectStore(DOCUMENTS_STORE, {\n            keyPath: 'id',\n          });\n          documentsStore.createIndex('by-created', 'createdAt');\n          documentsStore.createIndex('by-updated', 'updatedAt');\n          documentsStore.createIndex('by-name', 'name');\n        }\n\n        // Create pages store\n        if (!db.objectStoreNames.contains(PAGES_STORE)) {\n          const pagesStore = db.createObjectStore(PAGES_STORE, {\n            keyPath: 'id',\n          });\n          pagesStore.createIndex('by-document', 'documentId');\n        }\n      },\n    });\n  }\n\n  /**\n   * Create a new document\n   */\n  async createDocument(document: Document): Promise<Document> {\n    if (!this.db) throw new Error('Database not initialized');\n\n    const tx = this.db.transaction([DOCUMENTS_STORE, PAGES_STORE], 'readwrite');\n\n    // Store document\n    await tx.objectStore(DOCUMENTS_STORE).add(document);\n\n    // Store pages\n    const pagesStore = tx.objectStore(PAGES_STORE);\n    for (const page of document.pages) {\n      await pagesStore.add({ ...page, documentId: document.id });\n    }\n\n    await tx.done;\n    return document;\n  }\n\n  /**\n   * Get a document by ID\n   */\n  async getDocument(id: string): Promise<Document | null> {\n    if (!this.db) throw new Error('Database not initialized');\n\n    const document = await this.db.get(DOCUMENTS_STORE, id);\n    if (!document) return null;\n\n    // Get pages for this document\n    const pages = await this.db.getAllFromIndex(PAGES_STORE, 'by-document', id);\n    document.pages = pages.sort((a, b) => a.pageNumber - b.pageNumber);\n\n    return document;\n  }\n\n  /**\n   * Update a document\n   */\n  async updateDocument(document: Document): Promise<Document> {\n    if (!this.db) throw new Error('Database not initialized');\n\n    document.updatedAt = new Date();\n\n    const tx = this.db.transaction([DOCUMENTS_STORE, PAGES_STORE], 'readwrite');\n\n    // Update document\n    await tx.objectStore(DOCUMENTS_STORE).put(document);\n\n    // Update pages\n    const pagesStore = tx.objectStore(PAGES_STORE);\n\n    // Delete existing pages\n    const existingPages = await pagesStore.index('by-document').getAllKeys(document.id);\n    for (const key of existingPages) {\n      await pagesStore.delete(key);\n    }\n\n    // Add updated pages\n    for (const page of document.pages) {\n      await pagesStore.add({ ...page, documentId: document.id });\n    }\n\n    await tx.done;\n    return document;\n  }\n\n  /**\n   * Delete a document\n   */\n  async deleteDocument(id: string): Promise<void> {\n    if (!this.db) throw new Error('Database not initialized');\n\n    const tx = this.db.transaction([DOCUMENTS_STORE, PAGES_STORE], 'readwrite');\n\n    // Delete document\n    await tx.objectStore(DOCUMENTS_STORE).delete(id);\n\n    // Delete pages\n    const pagesStore = tx.objectStore(PAGES_STORE);\n    const pageKeys = await pagesStore.index('by-document').getAllKeys(id);\n    for (const key of pageKeys) {\n      await pagesStore.delete(key);\n    }\n\n    await tx.done;\n  }\n\n  /**\n   * List all documents\n   */\n  async listDocuments(options?: ListOptions): Promise<Document[]> {\n    if (!this.db) throw new Error('Database not initialized');\n\n    const sortBy = options?.sortBy || 'updatedAt';\n    const sortOrder = options?.sortOrder || 'desc';\n    const limit = options?.limit;\n    const offset = options?.offset || 0;\n\n    let documents: Document[];\n\n    if (sortBy === 'name') {\n      documents = await this.db.getAllFromIndex(DOCUMENTS_STORE, 'by-name');\n    } else if (sortBy === 'createdAt') {\n      documents = await this.db.getAllFromIndex(DOCUMENTS_STORE, 'by-created');\n    } else {\n      documents = await this.db.getAllFromIndex(DOCUMENTS_STORE, 'by-updated');\n    }\n\n    // Sort\n    if (sortOrder === 'desc') {\n      documents.reverse();\n    }\n\n    // Get pages for each document\n    for (const doc of documents) {\n      const pages = await this.db.getAllFromIndex(PAGES_STORE, 'by-document', doc.id);\n      doc.pages = pages.sort((a, b) => a.pageNumber - b.pageNumber);\n    }\n\n    // Apply pagination\n    if (limit !== undefined) {\n      documents = documents.slice(offset, offset + limit);\n    } else if (offset > 0) {\n      documents = documents.slice(offset);\n    }\n\n    return documents;\n  }\n\n  /**\n   * Search documents by text\n   */\n  async searchDocuments(query: string): Promise<SearchResult[]> {\n    if (!this.db) throw new Error('Database not initialized');\n\n    const documents = await this.listDocuments();\n    const results: SearchResult[] = [];\n    const lowerQuery = query.toLowerCase();\n\n    for (const doc of documents) {\n      for (const page of doc.pages) {\n        if (page.ocrResult) {\n          const matches: SearchResult['matches'] = [];\n          const text = page.ocrResult.text.toLowerCase();\n          let position = text.indexOf(lowerQuery);\n\n          while (position !== -1) {\n            matches.push({\n              text: page.ocrResult.text.substr(position, query.length),\n              position,\n            });\n            position = text.indexOf(lowerQuery, position + 1);\n          }\n\n          if (matches.length > 0) {\n            results.push({\n              documentId: doc.id,\n              pageId: page.id,\n              matches,\n            });\n          }\n        }\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Get storage usage information\n   */\n  async getStorageUsage(): Promise<StorageUsage> {\n    if (!navigator.storage || !navigator.storage.estimate) {\n      return {\n        used: 0,\n        quota: 0,\n        percentage: 0,\n      };\n    }\n\n    const estimate = await navigator.storage.estimate();\n    const used = estimate.usage || 0;\n    const quota = estimate.quota || 0;\n    const percentage = quota > 0 ? (used / quota) * 100 : 0;\n\n    return {\n      used,\n      quota,\n      percentage,\n    };\n  }\n\n  /**\n   * Clear all data\n   */\n  async clearAll(): Promise<void> {\n    if (!this.db) throw new Error('Database not initialized');\n\n    const tx = this.db.transaction([DOCUMENTS_STORE, PAGES_STORE], 'readwrite');\n    await tx.objectStore(DOCUMENTS_STORE).clear();\n    await tx.objectStore(PAGES_STORE).clear();\n    await tx.done;\n  }\n\n  /**\n   * Add a page to a document\n   */\n  async addPage(documentId: string, page: DocumentPage): Promise<void> {\n    if (!this.db) throw new Error('Database not initialized');\n\n    const document = await this.getDocument(documentId);\n    if (!document) throw new Error('Document not found');\n\n    document.pages.push(page);\n    document.metadata.totalPages = document.pages.length;\n    await this.updateDocument(document);\n  }\n\n  /**\n   * Remove a page from a document\n   */\n  async removePage(documentId: string, pageId: string): Promise<void> {\n    if (!this.db) throw new Error('Database not initialized');\n\n    const document = await this.getDocument(documentId);\n    if (!document) throw new Error('Document not found');\n\n    document.pages = document.pages.filter((p) => p.id !== pageId);\n\n    // Renumber pages\n    document.pages.forEach((p, index) => {\n      p.pageNumber = index + 1;\n    });\n\n    document.metadata.totalPages = document.pages.length;\n    await this.updateDocument(document);\n  }\n\n  /**\n   * Reorder pages in a document\n   */\n  async reorderPages(documentId: string, pageIds: string[]): Promise<void> {\n    if (!this.db) throw new Error('Database not initialized');\n\n    const document = await this.getDocument(documentId);\n    if (!document) throw new Error('Document not found');\n\n    const pageMap = new Map(document.pages.map((p) => [p.id, p]));\n    document.pages = pageIds.map((id) => pageMap.get(id)!).filter(Boolean);\n\n    // Renumber pages\n    document.pages.forEach((p, index) => {\n      p.pageNumber = index + 1;\n    });\n\n    await this.updateDocument(document);\n  }\n\n  /**\n   * Export a document's data for sharing\n   */\n  async exportDocument(documentId: string): Promise<Blob> {\n    if (!this.db) throw new Error('Database not initialized');\n\n    const document = await this.getDocument(documentId);\n    if (!document) throw new Error('Document not found');\n\n    const json = JSON.stringify(document, null, 2);\n    return new Blob([json], { type: 'application/json' });\n  }\n\n  /**\n   * Import a document from exported data\n   */\n  async importDocument(data: Blob): Promise<Document> {\n    if (!this.db) throw new Error('Database not initialized');\n\n    const text = await data.text();\n    const document: Document = JSON.parse(text);\n\n    // Convert date strings back to Date objects\n    document.createdAt = new Date(document.createdAt);\n    document.updatedAt = new Date(document.updatedAt);\n\n    await this.createDocument(document);\n    return document;\n  }\n}\n\n// Singleton instance\nlet storageServiceInstance: StorageService | null = null;\n\nexport async function getStorageService(): Promise<StorageService> {\n  if (!storageServiceInstance) {\n    storageServiceInstance = new StorageService();\n    await storageServiceInstance.initialize();\n  }\n  return storageServiceInstance;\n}\n","import { jsPDF } from 'jspdf';\nimport type {\n  Document,\n  DocumentPage,\n  PDFExportOptions,\n  ImageExportOptions,\n} from '@/types';\n\nexport class ExportService {\n  /**\n   * Export a document as PDF\n   */\n  async exportToPDF(\n    document: Document,\n    options: PDFExportOptions\n  ): Promise<Blob> {\n    const pageSize = this.getPageSize(options.pageSize);\n    const orientation = this.getOrientation(document, options.orientation);\n\n    const pdf = new jsPDF({\n      orientation,\n      unit: 'mm',\n      format: options.pageSize === 'original' ? [pageSize.width, pageSize.height] : options.pageSize,\n    });\n\n    // Add metadata\n    if (options.metadata) {\n      if (options.metadata.title) pdf.setProperties({ title: options.metadata.title });\n      if (options.metadata.author) pdf.setProperties({ author: options.metadata.author });\n      if (options.metadata.subject) pdf.setProperties({ subject: options.metadata.subject });\n    }\n\n    // Add pages\n    for (let i = 0; i < document.pages.length; i++) {\n      const page = document.pages[i];\n\n      if (i > 0) {\n        pdf.addPage();\n      }\n\n      // Convert page image to data URL\n      const imageData = await this.blobToDataURL(page.processedImage);\n\n      // Calculate dimensions\n      const pdfWidth = pdf.internal.pageSize.getWidth();\n      const pdfHeight = pdf.internal.pageSize.getHeight();\n\n      if (options.pageSize === 'original') {\n        // Use original image dimensions\n        const imgWidth = page.dimensions.width;\n        const imgHeight = page.dimensions.height;\n        const aspectRatio = imgWidth / imgHeight;\n\n        let width = pdfWidth;\n        let height = pdfWidth / aspectRatio;\n\n        if (height > pdfHeight) {\n          height = pdfHeight;\n          width = pdfHeight * aspectRatio;\n        }\n\n        const x = (pdfWidth - width) / 2;\n        const y = (pdfHeight - height) / 2;\n\n        pdf.addImage(imageData, 'JPEG', x, y, width, height);\n      } else {\n        // Fit to page size\n        pdf.addImage(imageData, 'JPEG', 0, 0, pdfWidth, pdfHeight);\n      }\n\n      // Add OCR text layer if requested and available\n      if (options.includeOCR && page.ocrResult) {\n        this.addTextLayer(pdf, page, pdfWidth, pdfHeight);\n      }\n    }\n\n    // Get PDF as blob\n    return pdf.output('blob');\n  }\n\n  /**\n   * Export a single page as image\n   */\n  async exportToImage(\n    page: DocumentPage,\n    options: ImageExportOptions\n  ): Promise<Blob> {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    if (!ctx) throw new Error('Failed to get canvas context');\n\n    // Load image from blob\n    const imageData = await this.blobToImageData(page.processedImage);\n\n    let width = imageData.width;\n    let height = imageData.height;\n\n    // Scale if maxDimension specified\n    if (options.maxDimension) {\n      const maxDim = Math.max(width, height);\n      if (maxDim > options.maxDimension) {\n        const scale = options.maxDimension / maxDim;\n        width = Math.round(width * scale);\n        height = Math.round(height * scale);\n      }\n    }\n\n    canvas.width = width;\n    canvas.height = height;\n\n    // Draw scaled image\n    const tempCanvas = document.createElement('canvas');\n    const tempCtx = tempCanvas.getContext('2d');\n    if (!tempCtx) throw new Error('Failed to get temp canvas context');\n\n    tempCanvas.width = imageData.width;\n    tempCanvas.height = imageData.height;\n    tempCtx.putImageData(imageData, 0, 0);\n\n    ctx.drawImage(tempCanvas, 0, 0, width, height);\n\n    // Convert to blob\n    return new Promise((resolve, reject) => {\n      canvas.toBlob(\n        (blob) => {\n          if (blob) {\n            resolve(blob);\n          } else {\n            reject(new Error('Failed to convert canvas to blob'));\n          }\n        },\n        options.format === 'png' ? 'image/png' : 'image/jpeg',\n        options.format === 'jpeg' ? options.quality / 100 : undefined\n      );\n    });\n  }\n\n  /**\n   * Export multiple pages as images (ZIP would be ideal but keeping it simple)\n   */\n  async exportMultipleImages(\n    document: Document,\n    options: ImageExportOptions\n  ): Promise<Blob[]> {\n    const blobs: Blob[] = [];\n\n    for (const page of document.pages) {\n      const blob = await this.exportToImage(page, options);\n      blobs.push(blob);\n    }\n\n    return blobs;\n  }\n\n  /**\n   * Export OCR text as plain text\n   */\n  async exportToText(document: Document, formatted: boolean = false): Promise<Blob> {\n    const texts: string[] = [];\n\n    if (formatted) {\n      // Export as Markdown\n      texts.push(`# ${document.name}\\n\\n`);\n      texts.push(`*Created: ${new Date(document.createdAt).toLocaleDateString()}*\\n\\n`);\n      texts.push(`---\\n\\n`);\n\n      for (const page of document.pages) {\n        if (page.ocrResult) {\n          texts.push(`## Page ${page.pageNumber}\\n\\n`);\n          texts.push(`${page.ocrResult.text}\\n\\n`);\n\n          if (page.ocrResult.confidence) {\n            texts.push(`*Confidence: ${page.ocrResult.confidence.toFixed(1)}%*\\n\\n`);\n          }\n\n          texts.push(`---\\n\\n`);\n        }\n      }\n    } else {\n      // Export as plain text\n      for (const page of document.pages) {\n        if (page.ocrResult) {\n          texts.push(`--- Page ${page.pageNumber} ---\\n\\n${page.ocrResult.text}\\n\\n`);\n        }\n      }\n    }\n\n    if (texts.length === 0) {\n      throw new Error('No OCR text available in this document');\n    }\n\n    const content = texts.join('');\n    return new Blob([content], { type: formatted ? 'text/markdown' : 'text/plain' });\n  }\n\n  /**\n   * Download a blob with a given filename\n   */\n  downloadBlob(blob: Blob, filename: string): void {\n    const url = URL.createObjectURL(blob);\n    const link = document.createElement('a');\n    link.href = url;\n    link.download = filename;\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n    URL.revokeObjectURL(url);\n  }\n\n  /**\n   * Share using Web Share API\n   */\n  async share(blob: Blob, filename: string, title: string): Promise<void> {\n    if (!navigator.share || !navigator.canShare) {\n      throw new Error('Web Share API not supported');\n    }\n\n    const file = new File([blob], filename, { type: blob.type });\n\n    if (!navigator.canShare({ files: [file] })) {\n      throw new Error('Cannot share this file type');\n    }\n\n    await navigator.share({\n      title,\n      files: [file],\n    });\n  }\n\n  /**\n   * Helper: Convert blob to data URL\n   */\n  private async blobToDataURL(blob: Blob): Promise<string> {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onloadend = () => resolve(reader.result as string);\n      reader.onerror = reject;\n      reader.readAsDataURL(blob);\n    });\n  }\n\n  /**\n   * Helper: Convert blob to ImageData\n   */\n  private async blobToImageData(blob: Blob): Promise<ImageData> {\n    return new Promise((resolve, reject) => {\n      const img = new Image();\n      img.onload = () => {\n        const canvas = document.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n        if (!ctx) {\n          reject(new Error('Failed to get canvas context'));\n          return;\n        }\n\n        canvas.width = img.width;\n        canvas.height = img.height;\n        ctx.drawImage(img, 0, 0);\n\n        const imageData = ctx.getImageData(0, 0, img.width, img.height);\n        resolve(imageData);\n      };\n      img.onerror = reject;\n      img.src = URL.createObjectURL(blob);\n    });\n  }\n\n  /**\n   * Helper: Get page size in mm\n   */\n  private getPageSize(size: PDFExportOptions['pageSize']): { width: number; height: number } {\n    switch (size) {\n      case 'a4':\n        return { width: 210, height: 297 };\n      case 'letter':\n        return { width: 216, height: 279 };\n      case 'legal':\n        return { width: 216, height: 356 };\n      default:\n        return { width: 210, height: 297 }; // Default to A4\n    }\n  }\n\n  /**\n   * Helper: Determine orientation\n   */\n  private getOrientation(\n    document: Document,\n    orientation: PDFExportOptions['orientation']\n  ): 'portrait' | 'landscape' {\n    if (orientation !== 'auto') return orientation;\n\n    // Auto-detect from first page\n    const firstPage = document.pages[0];\n    if (firstPage) {\n      return firstPage.dimensions.width > firstPage.dimensions.height\n        ? 'landscape'\n        : 'portrait';\n    }\n\n    return 'portrait';\n  }\n\n  /**\n   * Helper: Add invisible text layer for searchable PDF\n   */\n  private addTextLayer(\n    pdf: jsPDF,\n    page: DocumentPage,\n    pdfWidth: number,\n    pdfHeight: number\n  ): void {\n    if (!page.ocrResult) return;\n\n    const scaleX = pdfWidth / page.dimensions.width;\n    const scaleY = pdfHeight / page.dimensions.height;\n\n    pdf.setTextColor(255, 255, 255); // White text (invisible)\n    pdf.setFontSize(8);\n\n    for (const word of page.ocrResult.words) {\n      const x = word.boundingBox.x * scaleX;\n      const y = word.boundingBox.y * scaleY;\n\n      pdf.text(word.text, x, y, {\n        renderingMode: 'invisible',\n      });\n    }\n  }\n}\n\n// Singleton instance\nlet exportServiceInstance: ExportService | null = null;\n\nexport function getExportService(): ExportService {\n  if (!exportServiceInstance) {\n    exportServiceInstance = new ExportService();\n  }\n  return exportServiceInstance;\n}\n","import JSZip from 'jszip';\nimport type {\n  Document,\n  PDFExportOptions,\n  ImageExportOptions,\n} from '@/types';\nimport { getExportService } from './ExportService';\n\nexport type BulkExportFormat = 'pdf' | 'images';\n\nexport interface BulkExportOptions {\n  format: BulkExportFormat;\n  pdfOptions?: PDFExportOptions;\n  imageOptions?: ImageExportOptions;\n}\n\nexport interface BulkExportProgress {\n  current: number;\n  total: number;\n  currentDocumentName: string;\n}\n\nexport class BulkExportService {\n  private exportService = getExportService();\n\n  /**\n   * Export multiple documents as a zip file\n   */\n  async exportDocumentsAsZip(\n    documents: Document[],\n    options: BulkExportOptions,\n    onProgress?: (progress: BulkExportProgress) => void\n  ): Promise<Blob> {\n    if (documents.length === 0) {\n      throw new Error('No documents selected for export');\n    }\n\n    const zip = new JSZip();\n\n    for (let i = 0; i < documents.length; i++) {\n      const document = documents[i];\n\n      // Report progress\n      if (onProgress) {\n        onProgress({\n          current: i + 1,\n          total: documents.length,\n          currentDocumentName: document.name,\n        });\n      }\n\n      const sanitizedName = this.sanitizeFilename(document.name);\n\n      if (options.format === 'pdf') {\n        // Export as PDF\n        const pdfBlob = await this.exportService.exportToPDF(\n          document,\n          options.pdfOptions || this.getDefaultPDFOptions()\n        );\n        zip.file(`${sanitizedName}.pdf`, pdfBlob);\n      } else {\n        // Export as images\n        const imageBlobs = await this.exportService.exportMultipleImages(\n          document,\n          options.imageOptions || this.getDefaultImageOptions()\n        );\n\n        // Create a folder for each document if it has multiple pages\n        if (imageBlobs.length > 1) {\n          const folder = zip.folder(sanitizedName);\n          if (folder) {\n            imageBlobs.forEach((blob, index) => {\n              const extension = options.imageOptions?.format === 'jpeg' ? 'jpg' : 'png';\n              folder.file(`page_${index + 1}.${extension}`, blob);\n            });\n          }\n        } else if (imageBlobs.length === 1) {\n          // Single page, add directly\n          const extension = options.imageOptions?.format === 'jpeg' ? 'jpg' : 'png';\n          zip.file(`${sanitizedName}.${extension}`, imageBlobs[0]);\n        }\n      }\n    }\n\n    // Generate zip file\n    return await zip.generateAsync({\n      type: 'blob',\n      compression: 'DEFLATE',\n      compressionOptions: {\n        level: 6,\n      },\n    });\n  }\n\n  /**\n   * Export selected documents (convenience method)\n   */\n  async exportSelectedDocuments(\n    documentIds: string[],\n    allDocuments: Document[],\n    options: BulkExportOptions,\n    onProgress?: (progress: BulkExportProgress) => void\n  ): Promise<Blob> {\n    const selectedDocs = allDocuments.filter((doc) =>\n      documentIds.includes(doc.id)\n    );\n    return this.exportDocumentsAsZip(selectedDocs, options, onProgress);\n  }\n\n  /**\n   * Get default PDF export options\n   */\n  private getDefaultPDFOptions(): PDFExportOptions {\n    return {\n      pageSize: 'a4',\n      orientation: 'auto',\n      quality: 'high',\n      includeOCR: false,\n      compression: true,\n    };\n  }\n\n  /**\n   * Get default image export options\n   */\n  private getDefaultImageOptions(): ImageExportOptions {\n    return {\n      format: 'png',\n      quality: 90,\n    };\n  }\n\n  /**\n   * Sanitize filename to be safe for file systems\n   */\n  private sanitizeFilename(filename: string): string {\n    return filename\n      .replace(/[^a-z0-9_\\-\\s]/gi, '_')\n      .replace(/\\s+/g, '_')\n      .substring(0, 100); // Limit length\n  }\n\n  /**\n   * Generate a default zip filename\n   */\n  generateZipFilename(documentCount: number, format: BulkExportFormat): string {\n    const timestamp = new Date().toISOString().split('T')[0];\n    const formatLabel = format === 'pdf' ? 'PDFs' : 'Images';\n    return `documents_${documentCount}_${formatLabel}_${timestamp}.zip`;\n  }\n}\n\n// Singleton instance\nlet bulkExportServiceInstance: BulkExportService | null = null;\n\nexport function getBulkExportService(): BulkExportService {\n  if (!bulkExportServiceInstance) {\n    bulkExportServiceInstance = new BulkExportService();\n  }\n  return bulkExportServiceInstance;\n}\n","import Tesseract, { createWorker, type Worker } from 'tesseract.js';\nimport type {\n  OCRConfig,\n  OCRResult,\n  OCRProgress,\n  OrientationResult,\n} from '@/types';\n\nexport class OCRService {\n  private worker: Worker | null = null;\n  private isInitialized = false;\n  private currentLanguages: string[] = ['eng'];\n\n  /**\n   * Initialize the OCR worker with specified languages\n   */\n  async initialize(\n    languages: string[] = ['eng'],\n    onProgress?: (progress: OCRProgress) => void\n  ): Promise<void> {\n    if (this.isInitialized && this.arraysEqual(languages, this.currentLanguages)) {\n      return;\n    }\n\n    // Terminate existing worker if languages changed\n    if (this.worker) {\n      await this.terminate();\n    }\n\n    try {\n      this.worker = await createWorker(languages.join('+'), 1, {\n        logger: (m) => {\n          if (onProgress) {\n            onProgress({\n              status: m.status,\n              progress: m.progress || 0,\n            });\n          }\n        },\n      });\n\n      this.currentLanguages = languages;\n      this.isInitialized = true;\n    } catch (error) {\n      console.error('Failed to initialize OCR worker:', error);\n      throw new Error('Failed to initialize OCR service');\n    }\n  }\n\n  /**\n   * Perform OCR on an image\n   */\n  async recognize(\n    image: ImageData | HTMLImageElement | HTMLCanvasElement,\n    config?: Partial<OCRConfig>\n  ): Promise<OCRResult> {\n    if (!this.worker || !this.isInitialized) {\n      throw new Error('OCR service not initialized');\n    }\n\n    const startTime = performance.now();\n\n    try {\n      // Configure the worker if options provided\n      if (config) {\n        if (config.pageSegMode !== undefined) {\n          await this.worker.setParameters({\n            tessedit_pageseg_mode: config.pageSegMode as any,\n          });\n        }\n\n        if (config.preserveInterwordSpaces !== undefined) {\n          await this.worker.setParameters({\n            preserve_interword_spaces: config.preserveInterwordSpaces ? '1' : '0',\n          });\n        }\n\n        if (config.characterWhitelist) {\n          await this.worker.setParameters({\n            tessedit_char_whitelist: config.characterWhitelist,\n          });\n        }\n\n        if (config.characterBlacklist) {\n          await this.worker.setParameters({\n            tessedit_char_blacklist: config.characterBlacklist,\n          });\n        }\n      }\n\n      // Perform recognition\n      const result = await this.worker.recognize(image);\n      const processingTime = performance.now() - startTime;\n\n      return this.formatResult(result.data, processingTime);\n    } catch (error) {\n      console.error('OCR recognition failed:', error);\n      throw new Error('Failed to perform OCR');\n    }\n  }\n\n  /**\n   * Detect text orientation\n   */\n  async detectOrientation(\n    image: ImageData | HTMLImageElement | HTMLCanvasElement\n  ): Promise<OrientationResult> {\n    if (!this.worker || !this.isInitialized) {\n      throw new Error('OCR service not initialized');\n    }\n\n    try {\n      const result = await this.worker.detect(image);\n      return {\n        degrees: result.data.orientation_degrees || 0,\n        confidence: result.data.orientation_confidence || 0,\n        script: result.data.script || 'Latin',\n      };\n    } catch (error) {\n      console.error('Orientation detection failed:', error);\n      throw new Error('Failed to detect orientation');\n    }\n  }\n\n  /**\n   * Preprocess image for better OCR results\n   */\n  preprocessForOCR(imageData: ImageData): ImageData {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    if (!ctx) throw new Error('Failed to get canvas context');\n\n    canvas.width = imageData.width;\n    canvas.height = imageData.height;\n    ctx.putImageData(imageData, 0, 0);\n\n    const data = imageData.data;\n\n    // Convert to grayscale and apply adaptive threshold\n    for (let i = 0; i < data.length; i += 4) {\n      const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;\n      data[i] = gray;\n      data[i + 1] = gray;\n      data[i + 2] = gray;\n    }\n\n    return imageData;\n  }\n\n  /**\n   * Terminate the worker and clean up resources\n   */\n  async terminate(): Promise<void> {\n    if (this.worker) {\n      await this.worker.terminate();\n      this.worker = null;\n      this.isInitialized = false;\n    }\n  }\n\n  /**\n   * Format Tesseract result to match our OCRResult type\n   */\n  private formatResult(data: Tesseract.Page, processingTime: number): OCRResult {\n    return {\n      text: data.text,\n      confidence: data.confidence,\n      words: data.words.map((word) => ({\n        text: word.text,\n        confidence: word.confidence,\n        boundingBox: {\n          x: word.bbox.x0,\n          y: word.bbox.y0,\n          width: word.bbox.x1 - word.bbox.x0,\n          height: word.bbox.y1 - word.bbox.y0,\n        },\n        baseline: {\n          x0: word.baseline.x0,\n          y0: word.baseline.y0,\n          x1: word.baseline.x1,\n          y1: word.baseline.y1,\n        },\n      })),\n      lines: data.lines.map((line) => ({\n        text: line.text,\n        confidence: line.confidence,\n        boundingBox: {\n          x: line.bbox.x0,\n          y: line.bbox.y0,\n          width: line.bbox.x1 - line.bbox.x0,\n          height: line.bbox.y1 - line.bbox.y0,\n        },\n        words: line.words.map((word) => ({\n          text: word.text,\n          confidence: word.confidence,\n          boundingBox: {\n            x: word.bbox.x0,\n            y: word.bbox.y0,\n            width: word.bbox.x1 - word.bbox.x0,\n            height: word.bbox.y1 - word.bbox.y0,\n          },\n          baseline: {\n            x0: word.baseline.x0,\n            y0: word.baseline.y0,\n            x1: word.baseline.x1,\n            y1: word.baseline.y1,\n          },\n        })),\n      })),\n      paragraphs: data.paragraphs.map((para) => ({\n        text: para.text,\n        confidence: para.confidence,\n        boundingBox: {\n          x: para.bbox.x0,\n          y: para.bbox.y0,\n          width: para.bbox.x1 - para.bbox.x0,\n          height: para.bbox.y1 - para.bbox.y0,\n        },\n        lines: para.lines.map((line) => ({\n          text: line.text,\n          confidence: line.confidence,\n          boundingBox: {\n            x: line.bbox.x0,\n            y: line.bbox.y0,\n            width: line.bbox.x1 - line.bbox.x0,\n            height: line.bbox.y1 - line.bbox.y0,\n          },\n          words: line.words.map((word) => ({\n            text: word.text,\n            confidence: word.confidence,\n            boundingBox: {\n              x: word.bbox.x0,\n              y: word.bbox.y0,\n              width: word.bbox.x1 - word.bbox.x0,\n              height: word.bbox.y1 - word.bbox.y0,\n            },\n            baseline: {\n              x0: word.baseline.x0,\n              y0: word.baseline.y0,\n              x1: word.baseline.x1,\n              y1: word.baseline.y1,\n            },\n          })),\n        })),\n      })),\n      blocks: (data.blocks || []).map((block) => ({\n        text: block.text,\n        confidence: block.confidence,\n        boundingBox: {\n          x: block.bbox.x0,\n          y: block.bbox.y0,\n          width: block.bbox.x1 - block.bbox.x0,\n          height: block.bbox.y1 - block.bbox.y0,\n        },\n        paragraphs: block.paragraphs.map((para) => ({\n          text: para.text,\n          confidence: para.confidence,\n          boundingBox: {\n            x: para.bbox.x0,\n            y: para.bbox.y0,\n            width: para.bbox.x1 - para.bbox.x0,\n            height: para.bbox.y1 - para.bbox.y0,\n          },\n          lines: para.lines.map((line) => ({\n            text: line.text,\n            confidence: line.confidence,\n            boundingBox: {\n              x: line.bbox.x0,\n              y: line.bbox.y0,\n              width: line.bbox.x1 - line.bbox.x0,\n              height: line.bbox.y1 - line.bbox.y0,\n            },\n            words: line.words.map((word) => ({\n              text: word.text,\n              confidence: word.confidence,\n              boundingBox: {\n                x: word.bbox.x0,\n                y: word.bbox.y0,\n                width: word.bbox.x1 - word.bbox.x0,\n                height: word.bbox.y1 - word.bbox.y0,\n              },\n              baseline: {\n                x0: word.baseline.x0,\n                y0: word.baseline.y0,\n                x1: word.baseline.x1,\n                y1: word.baseline.y1,\n              },\n            })),\n          })),\n        })),\n      })),\n      processingTime,\n    };\n  }\n\n  /**\n   * Helper to compare arrays\n   */\n  private arraysEqual(a: string[], b: string[]): boolean {\n    if (a.length !== b.length) return false;\n    return a.every((val, index) => val === b[index]);\n  }\n}\n\n// Singleton instance\nlet ocrServiceInstance: OCRService | null = null;\n\nexport function getOCRService(): OCRService {\n  if (!ocrServiceInstance) {\n    ocrServiceInstance = new OCRService();\n  }\n  return ocrServiceInstance;\n}\n"],"names":["cameraService","constructor","__publicField","this","initialize","config","finalConfig","facingMode","resolution","ideal","width","height","min","focusMode","torch","currentFacingMode","constraints","video","audio","stream","navigator","mediaDevices","getUserMedia","videoTrack","getVideoTracks","error","fallbackConstraints","getCapabilities","capabilities","hasFlash","hasFocus","hasZoom","maxZoom","zoom","max","supportedResolutions","getSupportedResolutions","resolutions","commonResolutions","maxWidth","maxHeight","res","push","switchCamera","newFacingMode","dispose","capturePhoto","videoElement","Error","canvas","document","createElement","videoWidth","videoHeight","ctx","getContext","drawImage","getImageData","getVideoFrame","Math","setZoom","level","advanced","applyConstraints","toggleFlash","enabled","setFocusPoint","x","y","getStream","getCurrentFacingMode","isInitialized","getTracks","forEach","track","stop","isOpenCVLoaded","window","cv","getOpenCV","imageDataToMat","imageData","matFromImageData","matToImageData","mat","cols","rows","imshow","deleteMat","mats","delete","edgeDetectionService","Promise","detectDocument","cannyThreshold1","cannyThreshold2","blurKernelSize","dilationIterations","minAreaRatio","maxAreaRatio","src","gray","blurred","edges","dilated","contours","hierarchy","Mat","cvtColor","COLOR_RGBA2GRAY","ksize","Size","GaussianBlur","Canny","kernel","ones","CV_8U","dilate","Point","MatVector","findContours","RETR_EXTERNAL","CHAIN_APPROX_SIMPLE","findBestQuadrilateral","imageWidth","imageHeight","imageArea","minArea","maxArea","bestContour","bestScore","i","size","contour","get","area","contourArea","perimeter","arcLength","approx","approxPolyDP","points","matToPoints","boundingRect","getBoundingRect","aspectRatio","score","scoreQuadrilateral","orderCorners","confidence","reduce","best","target","diff","abs","currentScore","isRoughlyConvex","length","crossProducts","p1","p2","p3","cross","allPositive","every","cp","allNegative","data32S","xs","map","p","ys","minX","maxX","minY","sorted","sort","a","b","topPoints","slice","bottomPoints","isReady","perspectiveCorrectionService","correctPerspective","corners","outputWidth","outputHeight","preserveAspectRatio","interpolation","dst","M","outputDimensions","calculateOutputDimensions","orderedCorners","ensureCornerOrder","srcPoints","matFromArray","CV_32FC2","dstPoints","getPerspectiveTransform","dsize","interpolationFlag","getInterpolationFlag","warpPerspective","BORDER_CONSTANT","Scalar","correctedImage","transformMatrix","matrixToArray","originalCorners","topWidth","distance","bottomWidth","leftHeight","rightHeight","round","dx","dy","sqrt","centroid","sum","atan2","sums","topLeftIndex","indexOf","INTER_NEAREST","INTER_LINEAR","INTER_CUBIC","INTER_LANCZOS4","result","row","j","data64F","imageEnhancementService","enhance","options","clone","brightness","contrast","alpha","beta","convertTo","gamma","applyGamma","saturation","applySaturation","applyFilter","preset","applyGrayscale","applyDocumentFilter","applyMagicFilter","applyWhiteboardFilter","applyBookFilter","applyReceiptFilter","applyPhotoFilter","applyBlueprintFilter","COLOR_GRAY2RGBA","denoised","threshold","fastNlMeansDenoising","adaptiveThreshold","ADAPTIVE_THRESH_GAUSSIAN_C","THRESH_BINARY","lab","channels","l","COLOR_RGBA2RGB","COLOR_RGB2Lab","split","clahe","CLAHE","apply","merge","COLOR_Lab2RGB","COLOR_RGB2RGBA","sharpened","CV_32F","filter2D","THRESH_OTSU","inverted","bitwise_not","lookupTable","Uint8Array","pow","data","hsv","COLOR_RGB2HSV","s","factor","COLOR_HSV2RGB","DOCUMENTS_STORE","PAGES_STORE","StorageService","db","openDB","upgrade","objectStoreNames","contains","documentsStore","createObjectStore","keyPath","createIndex","createDocument","tx","transaction","objectStore","add","pagesStore","page","pages","documentId","id","done","getDocument","getAllFromIndex","pageNumber","updateDocument","updatedAt","Date","put","existingPages","index","getAllKeys","key","deleteDocument","pageKeys","listDocuments","sortBy","sortOrder","limit","offset","documents","reverse","doc","searchDocuments","query","results","lowerQuery","toLowerCase","ocrResult","matches","text","position","substr","pageId","getStorageUsage","storage","estimate","used","quota","percentage","usage","clearAll","clear","addPage","metadata","totalPages","removePage","filter","reorderPages","pageIds","pageMap","Map","Boolean","exportDocument","json","JSON","stringify","Blob","type","importDocument","parse","createdAt","storageServiceInstance","async","getStorageService","ExportService","exportToPDF","pageSize","getPageSize","orientation","getOrientation","pdf","jsPDF","unit","format","title","setProperties","author","subject","blobToDataURL","processedImage","pdfWidth","internal","getWidth","pdfHeight","getHeight","dimensions","addImage","includeOCR","addTextLayer","output","exportToImage","blobToImageData","maxDimension","maxDim","scale","tempCanvas","tempCtx","putImageData","resolve","reject","toBlob","blob","quality","exportMultipleImages","blobs","exportToText","formatted","texts","name","toLocaleDateString","toFixed","content","join","downloadBlob","filename","url","URL","createObjectURL","link","href","download","body","appendChild","click","removeChild","revokeObjectURL","share","canShare","file","File","files","reader","FileReader","onloadend","onerror","readAsDataURL","img","Image","onload","firstPage","scaleX","scaleY","setTextColor","setFontSize","word","words","boundingBox","renderingMode","exportServiceInstance","getExportService","BulkExportService","exportDocumentsAsZip","onProgress","zip","JSZip","current","total","currentDocumentName","sanitizedName","sanitizeFilename","pdfBlob","exportService","pdfOptions","getDefaultPDFOptions","imageBlobs","imageOptions","getDefaultImageOptions","folder","extension","generateAsync","compression","compressionOptions","exportSelectedDocuments","documentIds","allDocuments","selectedDocs","includes","replace","substring","generateZipFilename","documentCount","toISOString","bulkExportServiceInstance","getBulkExportService","OCRService","languages","arraysEqual","currentLanguages","worker","terminate","createWorker","logger","m","status","progress","recognize","image","startTime","performance","now","pageSegMode","setParameters","tessedit_pageseg_mode","preserveInterwordSpaces","preserve_interword_spaces","characterWhitelist","tessedit_char_whitelist","characterBlacklist","tessedit_char_blacklist","processingTime","formatResult","detectOrientation","detect","degrees","orientation_degrees","orientation_confidence","script","preprocessForOCR","bbox","x0","y0","x1","y1","baseline","lines","line","paragraphs","para","blocks","block","val","ocrServiceInstance","getOCRService"],"mappings":"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"}